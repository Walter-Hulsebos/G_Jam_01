// Weaver // https://kybernetik.com.au/weaver // Copyright 2021 Kybernetik //

#if UNITY_EDITOR

#define ASK_FOR_SCRIPT_PATH

using System;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;
using Debug = UnityEngine.Debug;
using Object = UnityEngine.Object;

namespace Weaver.Editor.Procedural
{
    /// <summary>[Editor-Only]
    /// An <see cref="AssetGenerator"/> which saves <see cref="MonoScript"/>s as ".cs" text files.
    /// </summary>
    [AssetGenerator(typeof(MonoScript))]
    public class ScriptGenerator : TextGenerator
    {
        /************************************************************************************************************************/

        /// <summary>.cs</summary>
        public override string DefaultFileExtension => ".cs";

        /************************************************************************************************************************/

        /// <summary>The contents of this <see cref="StringBuilder"/> will be logged and cleared once the current script finishes generating.</summary>
        public static StringBuilder SaveMessage { get; private set; }

        /************************************************************************************************************************/

        /// <summary>
        /// Invokes `asset.GeneratorMethod` with the correct parameters for this <see cref="AssetGenerator"/>.
        /// </summary>
        public override Object InvokeGeneratorMethod(ProceduralAsset asset)
        {
            if (WeaverSettings.ProceduralAssets.notifyWhenGeneratingScripts)
            {
                SaveMessage = WeaverUtilities.GetStringBuilder()
                    .Append("Generated Procedural Script: ")
                    .AppendLineConst(ProceduralAsset.CurrentAssetPath);
            }

            base.InvokeGeneratorMethod(asset);
            DisableSaveMessage();
            return null;
        }

        /************************************************************************************************************************/

        /// <summary>
        /// Prevents the "Generated Procedural Script: ..." message from being logged for the currently generating
        /// script.
        /// </summary>
        public static void DisableSaveMessage()
        {
            if (SaveMessage != null)
            {
                SaveMessage.Release();
                SaveMessage = null;
            }
        }

        /************************************************************************************************************************/

        /// <summary>Appends "// This file was procedurally generated by ...".</summary>
        public override void AppendHeader(StringBuilder script, ProceduralAsset asset)
        {
            script.Append("// This file was procedurally generated by ");

            var alias = AliasAttribute.GetAlias(asset.GeneratorMethod);
            if (alias != null)
                script.Append(alias);
            else
                CSharp.AppendSignature(asset.GeneratorMethod, script, CSharp.NameVerbosity.Full, false, true, false);

            script.AppendLineConst(". Any modifications will be overwritten.");

            script.AppendLineConst();
        }

        /// <summary>Logs the <see cref="SaveMessage"/>.</summary>
        protected override void OnSaveText(ProceduralAsset asset)
        {
            if (SaveMessage != null)
            {
                SaveMessage.AppendLineConst();
                SaveMessage.AppendLineConst($"You can disable these notifications via '{WeaverUtilities.WeaverWindowPath}'");
                Debug.Log(SaveMessage, asset.Injector.Asset);
            }
        }

        /************************************************************************************************************************/

        /// <summary>Adds the `reason` that the script at the specified `assetPath` should be rebuilt to the save message.</summary>
        public static void LogRebuildReason(string assetPath, string reason)
        {
            if (SaveMessage != null)
                SaveMessage.Append("Rebuilding ").Append(assetPath).Append(" because ").AppendLine(reason);
        }

        /************************************************************************************************************************/

        /// <summary>Populates `menu` with various items for the context menu of `asset`.</summary>
        public override void AddItemsToMenu(GenericMenu menu, ProceduralAsset asset)
        {
            var builder = SimpleScriptBuilder.GetBuilderInstance(asset.GeneratorMethod.DeclaringType);
            if (builder != null)
            {
                var content = new GUIContent("Clear Obsolete Members");

                if (builder.ShouldBuild() || builder.HasAnyObsoleteMembers())
                    menu.AddItem(content, false, builder.RebuildScriptWithoutObsoleteMembers);
                else
                    menu.AddDisabledItem(content);
            }

            base.AddItemsToMenu(menu, asset);
            WeaverEditorUtilities.AddLinkToURL(menu, "Help/Procedural Scripts", "/docs/procedural-assets/procedural-scripts");
        }

        /************************************************************************************************************************/

        /// <summary>
        /// Replaces the method name used in the "This file was procedurally generated by ... Any modifications will be
        /// overwritten." comment at the top of a procedural script.
        /// </summary>
        [AttributeUsage(AttributeTargets.Method)]
        public sealed class AliasAttribute : Attribute
        {
            /// <summary>The name to use.</summary>
            public readonly string GeneratedBy;

            /// <summary>Creates a new <see cref="AliasAttribute"/> and sets the <see cref="GeneratedBy"/> field.</summary>
            public AliasAttribute(string generatedBy)
            {
                GeneratedBy = generatedBy;
            }

            /// <summary>
            /// Returns the alias of the specified `script` if it has an <see cref="AliasAttribute"/>, otherwise
            /// the full name of its generator method is used.
            /// </summary>
            public static string GetAlias(MethodInfo generatorMethod)
            {
                var alias = generatorMethod.GetAttribute<AliasAttribute>(false);
                if (alias != null)
                    return alias.GeneratedBy;
                else
                    return generatorMethod.GetNameCS();
            }
        }

        /************************************************************************************************************************/
    }
}

#endif

